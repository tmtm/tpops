#!/usr/local/bin/ruby
# $Id: tpops,v 1.46 2004/05/31 18:02:08 tommy Exp $
#
# Copyright (C) 2003-2004 TOMITA Masahiro
# tommy@tmtm.org
#

require "getopts"
require "syslog"
require "etc"
require File.dirname($0)+"/tserver"

$version = "0.6"

$port = 110
$hostname = `uname -n`.chomp
$connection_keep_time = 60*60
$command_timeout = 10*60
$with_inetd = false
$access_log = nil
$error_log = nil
$syslog_facility = Syslog::LOG_MAIL
$auth_type = "Passwd"
$mailbox_type = "Maildir"
$error_interval = 5
$min_servers = 5
$max_servers = 50
$max_use = 100
$max_idle = 100
$pid_file = nil

def log_debug(str)
  Syslog.debug("%s", str) if $syslog_facility and $debug
end

def log_info(str)
  Syslog.info("%s", str) if $syslog_facility
end

def log_notice(str)
  Syslog.notice("%s", str) if $syslog_facility
end

def log_warn(str)
  Syslog.warning("%s", str) if $syslog_facility
end

def log_err(str)
  Syslog.err("%s", str) if $syslog_facility
end

class TPOPS

  class Error < StandardError
  end

  def initialize()
    at_exit do
      File.unlink $old_pid_file rescue nil if $old_pid_file
    end
    ts = nil
    loop do
      load_config
      call_by_inetd if $with_inetd

      if $port != $old_port then
        ts.close if ts
        ts = TServer.new($port)
        $old_port = $port
      end

      ts.handle_signal = false
      ts.on_child_start = Proc.new do
        Process.uid = $uid if $uid
        Process.euid = $uid if $uid
        Process.gid = $gid if $gid
      end
      unless $signal_setup then
        trap "HUP" do
          ts.terminate
          ts.stop
        end
        trap "TERM" do
          ts.terminate
          exit
        end
        trap "INT" do
          ts.interrupt
          exit
        end
        $signal_setup = true
      end

      if $error_log then
        File.open($error_log, "a") do |f|
          $stderr.reopen f
        end
      end
      if not $foreground and not $already_forked then
        if fork then
          exit
        end
        Process.setsid
        $already_forked = true
      end
      File.unlink $old_pid_file rescue nil if $old_pid_file
      $old_pid_file = nil
      if $pid_file then
        File.open($pid_file, "w") do |f| f.puts $$ end
        $old_pid_file = $pid_file
      end

      ts.min_servers = $min_servers
      ts.max_servers = $max_servers
      ts.max_use = $max_use
      ts.max_idle = $max_idle
      ts.start do |conn|
        begin
          Conn.new conn
        rescue TPOPS::Error
          log_err $!.to_s
          exit 1
        rescue
          log_err $!.to_s
          $stderr.puts Time.now.inspect
          $stderr.flush
          raise
        end
      end
    end
  end

  def call_by_inetd()
    File.open($error_log || "/dev/null", "a") do |f|
      $stderr.reopen f
    end
    begin
      Process.uid = $uid if $uid
      Process.euid = $uid if $uid
      Process.gid = $gid if $gid
      Conn.new(Socket.for_fd($stdin.fileno))
    rescue TPOPS::Error
      log_err $!.to_s
    rescue
      log_err $!.to_s
      $stderr.puts Time.now.inspect
      $stderr.flush
      raise
    end
    exit
  end

  def load_config()
    script_dir = File.dirname $0
    if $OPT_f then
      load $OPT_f
    else
      load script_dir+"/tpops.conf" if File.exist? script_dir+"/tpops.conf"
    end
    require script_dir+"/tpops_auth-"+$auth_type.downcase
    require script_dir+"/tpops_mailbox-"+$mailbox_type.downcase
    $default_domain = $OPT_domain if $OPT_domain
    $foreground = $OPT_fg if $OPT_fg
    $port = $OPT_port.to_i if $OPT_port
    $debug = $OPT_debug if $OPT_debug
    $pid_file = $OPT_pidfile if $OPT_pidfile
    $with_inetd = true if $OPT_inetd
    $user = $OPT_user if $OPT_user
    $group = $OPT_group if $OPT_group
    if $user then
      if $user.is_a? Integer then
        $uid = $user
      else
        $uid = $user =~ /^\d+$/ ? $user.to_i : Etc.getpwnam($user).uid
      end
    end
    if $group then
      if $group.is_a? Integer then
        $gid = $group
      else
        $gid = $group =~ /^\d+$/ ? $group.to_i : Etc.getgrnam($group).gid
      end
    end
    if $syslog_facility then
      Syslog.close if Syslog.opened?
      Syslog.open(File.basename($0), nil, $syslog_facility)
    end
  end

  class Conn
    def initialize(sock)
      @sock = sock
      @status = :AUTHORIZATION
      @user = nil
      @apopkey = Auth.apop? ? "<#{$$}.#{Time.now.to_i}@#{$hostname}>" : ""
      @start_time = Time.now
      @peer_addr = sock_to_addr @sock

      log_info "connect from #{@peer_addr}"

      def @sock.connect_time=(t)
	@connect_time = t
      end

      def @sock.gets()
	ret = ""
	loop do
	  if IO.select([self], nil, nil, $command_timeout) == nil then
	    raise TPOPS::Error, "Command timeout"
	  end
	  if Time.now.to_i - @connect_time > $connection_keep_time then
	    raise TPOPS::Error, "Connection time exceeded"
	  end
	  chr = getc
	  break if chr == nil
	  ret << chr
	  break if chr == ?\n
	  raise TPOPS::Error, "line exceed 1024 bytes" if ret.length >= 1024
	end
	ret == "" ? nil : ret
      end

      def @sock.write(str)
        begin
          super str
        rescue
          raise TPOPS::Error, $!.to_s
        end
      end

      @sock.connect_time = Time.now.to_i
      ok "TPOPS ready. #{@apopkey}"
      begin
	catch :disconnect do
	  loop do
	    r = @sock.gets
	    if not r then
              log_warn "connection closed unexpectedly"
              break
            end
	    r = r.chomp.sub(/\r$/, "")
	    log_debug "< #{r}"
	    comm = r.split
	    if comm.size == 0 then next end
	    case @status
	    when :AUTHORIZATION
	      case comm[0].upcase
	      when "QUIT";	comm_auth_quit comm[1..-1]
	      when "USER";	comm_user comm[1..-1]
	      when "PASS";	comm_pass r.split(" ", 2)[1,1]
	      when "APOP";	comm_apop comm[1..-1]
	      else
		err "invalid command"
	      end
	    when :TRANSACTION
	      case comm[0].upcase
	      when "STAT";	comm_stat comm[1..-1]
	      when "LIST";	comm_list comm[1..-1]
	      when "RETR";	comm_retr comm[1..-1]
	      when "DELE";	comm_dele comm[1..-1]
	      when "NOOP";	comm_noop comm[1..-1]
	      when "RSET";	comm_rset comm[1..-1]
	      when "TOP" ;	comm_top comm[1..-1]
	      when "UIDL";	comm_uidl comm[1..-1]
	      when "QUIT";	comm_quit comm[1..-1]
	      else
		err "invalid command"
	      end
	    end
	  end
	end
      ensure
	@auth.unlock if @auth and @auth.locked? rescue nil
	write_log rescue nil
	@sock.close rescue nil
	log_info "disconnect from #{@peer_addr}" rescue nil
      end
    end

    def err(arg=nil)
      sleep $error_interval
      @sock.write(arg ? "-ERR #{arg}\r\n" : "-ERR\r\n")
      log_debug "> -ERR #{arg}"
    end

    def ok(arg=nil)
      @sock.write(arg ? "+OK #{arg}\r\n" : "+OK\r\n")
      log_debug "> +OK #{arg}"
    end

    def comm_auth_quit(arg)
      if arg.size != 0 then
	err "too many arguments"
	return
      end
      ok "server signing off" rescue true
      throw :disconnect
    end

    def comm_user(arg)
      if @user then
	err "invalid command"
	return
      end
      if arg.size != 1 then
	err "too few/many arguments"
	return
      end
      ok "password required"
      @user = arg[0]
      if $default_domain and @user !~ /[@%\+]/ then
	@user = @user+"@"+$default_domain
      end
    end

    def comm_pass(arg)
      if not @user then
	err "invalid command"
	return
      end
      if arg.size != 1 then
	err "too few/many arguments"
	return
      end

      @auth = Auth.new @user, arg[0]
      if @auth.authorized? then
	to_transaction
      else
	log_notice "authentication failed: #{@user}"
	err "authentication failed"
	throw :disconnect
      end
    end

    def comm_apop(arg)
      unless Auth.apop? then
	err "APOP not supported"
	return
      end
      if @user then
	err "invalid command"
	return
      end
      if arg.size != 2 then
	err "too few/many arguments"
	return
      end
      @user = arg[0]
      @auth = Auth.new arg[0], arg[1], @apopkey
      if @auth.authorized? then
	to_transaction
      else
	log_notice "authentication failed: #{@user}"
	err "authentication failed"
	throw :disconnect
      end
    end  

    def to_transaction()
      if not @auth.lock then
	log_notice "cannot lock for #{@user}"
	err "cannot lock for #{@user}"
	throw :disconnect
      end
      @mailbox = Mailbox.new @auth.uid, @auth.maildir
      after_auth_hook(@sock, @auth, @mailbox) if defined? after_auth_hook
      @status = :TRANSACTION
      msgs, size = @mailbox.stat
      @start_mailbox = [msgs, size]
      ok "#{@user} has #{msgs} messages (#{size} octets)"
      log_info "login: #{@user} has #{msgs} messages (#{size} octets)"
    end

    def write_log()
      if @mailbox then
	msgs, size = @mailbox.real_stat
      else
	msgs, size = 0, 0
      end
      if @status == :TRANSACTION then
	log_info "logout: #{@user} has #{msgs} messages (#{size} octets)"
      end
      if $access_log then
	if @start_mailbox then
	  s_msgs, s_size = @start_mailbox
	else
	  s_msgs, s_size = 0, 0
	end
	u = @user == nil ? "()" : @status == :TRANSACTION ? @user : "(#{@user})"
	File.open($access_log, "a") do |f|
	  f.syswrite sprintf("%s %s %s %s %d %d %d %d\n",
	    @peer_addr, @start_time.strftime("%Y/%m/%d %H:%M:%S"),
	    Time.now.strftime("%Y/%m/%d %H:%M:%S"),
	    u, s_msgs, s_size, msgs, size)
	end
      end
    end

    def sock_to_addr(s)
      s.getpeername[4,4].split("").collect{|i| i[0].to_s}.join(".")
    end

    def comm_stat(arg)
      if arg.size != 0 then
	err "too many arguments"
	return
      end
      n, m = @mailbox.stat
      ok "#{n} #{m}"
    end

    def comm_list(arg)
      if arg.size == 0 then
	n, m = @mailbox.stat
	ok "#{n} messages (#{m} octets)"
	@sock.sync = false
	@mailbox.list_all.each do |n, m|
	  @sock.write "#{n} #{m}\r\n"
	end
	@sock.sync = true
	@sock.write ".\r\n"
      elsif arg.size == 1 then
	n, m = @mailbox.list(arg[0].to_i)
	if n then
	  ok "#{n} #{m}"
	else
	  err "no such message"
	end
      else
	err "too many arguments"
      end
    end

    def comm_retr(arg)
      if arg.size != 1 then
	err "too few/many arguments"
	return
      end
      m, size = @mailbox.list(arg[0].to_i)
      if not m then
	err "no such message"
	return
      end
      ok "#{size} octets"
      @sock.sync = false
      @mailbox.retr(arg[0].to_i) do |line|
	if line[0] == ?. then line[0,0] = "." end
	@sock.write line
      end
      @sock.sync = true
      @sock.write ".\r\n"
    end

    def comm_dele(arg)
      if arg.size != 1 then
	err "too few/many arguments"
	return
      end
      if @mailbox.dele(arg[0].to_i) then
	ok "message deleted"
      else
	err "no such message"
      end
    end

    def comm_noop(arg)
      if arg.size != 0 then
	err "too many arguments"
	return
      end
      ok
    end

    def comm_rset(arg)
      if arg.size != 0 then
	err "too many arguments"
	return
      end
      @mailbox.rset
      ok
    end

    def comm_top(arg)
      if arg.size != 2 then
	err "too few/many arguments"
	return
      end
      if not @mailbox.list(arg[0].to_i) then
	err "no such message"
	return
      end
      ok
      @sock.sync = false
      @mailbox.top(arg[0].to_i, arg[1].to_i) do |line|
	if line[0] == ?. then line[0,0] = "." end
	@sock.write line
      end
      @sock.sync = true
      @sock.write ".\r\n"
    end

    def comm_uidl(arg)
      if arg.size == 0 then
	ok
	@sock.sync = false
	@mailbox.uidl_all.each do |m, id|
	  @sock.write "#{m} #{id}\r\n"
	end
	@sock.sync = true
	@sock.write ".\r\n"
      elsif arg.size == 1 then
	m, id = @mailbox.uidl(arg[0].to_i)
	if m then
	  ok "#{m} #{id}"
	else
	  err "no such message"
	end
      else
	err "too many arguments"
      end
    end

    def comm_quit(arg)
      if arg.size != 0 then
	err "too many arguments"
	return
      end
      @mailbox.commit
      ok "server signing off" rescue true
      throw :disconnect
    end
  end

end

unless getopts(nil, "f:", "domain:", "fg", "port:", "debug", "version", "inetd", "user:", "group:", "pidfile:") then
  raise TPOPS::Error, "unknown options"
end
if $OPT_version then
  puts "TPOPS version #{$version}"
  exit
end

TPOPS.new
