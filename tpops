#!/usr/local/bin/ruby
# $Id: tpops,v 1.13.2.2 2002/02/24 18:01:51 tommy Exp $

require 'socket'

ScriptDir = $0.sub(/[^\/]*$/, '')
load ScriptDir+'tpops.conf'
Mailbox = 'MySQL' unless defined? Mailbox
case Mailbox
when 'Maildir'
  load ScriptDir+'tpops_maildir.rb'
else
  load ScriptDir+'tpops_sub.rb'
end

class TPOPS

  def initialize()
    if defined? WithInetd and WithInetd then
      $stderr = File::open(ErrorFile, 'a')
      connection(Socket::for_fd $stdin.fileno)
    else
      trap "CHLD", nil		# ignore child process's status
      sock = TCPServer::new(Port)
      loop do
	conn = sock.accept
	fork do
	  sock.close
	  connection(conn)
	end
	conn.close
      end
    end
  end

  def connection(sock)
    @sock = sock
    @status = :AUTHORIZATION
    @user = nil
    @apopkey = "<#{$$}.#{Time::now.to_i}@#{Hostname}>"

    Thread::new do sleep ConnectionKeepTime; exit end

    @sock.write "+OK TPOPS ready. #{@apopkey}\r\n"
    loop do
      timeout_thr = Thread::new do sleep CommandTimeout; exit end
      r = @sock.gets
      timeout_thr.kill
      if not r then break end
      r = r.chomp.sub(/\r$/, '')
      comm = r.split
      if comm.size == 0 then next end
      case @status
      when :AUTHORIZATION
	case comm[0].upcase
	when 'QUIT';	comm_auth_quit comm[1..-1]
	when 'USER';	comm_user comm[1..-1]
	when 'PASS';	comm_pass r.split(' ', 2)[1,1]
	when 'APOP';	comm_apop comm[1..-1]
	else
	  err 'invalid command'
	end
      when :TRANSACTION
	case comm[0].upcase
	when 'STAT';	comm_stat comm[1..-1]
	when 'LIST';	comm_list comm[1..-1]
	when 'RETR';	comm_retr comm[1..-1]
	when 'DELE';	comm_dele comm[1..-1]
	when 'NOOP';	comm_noop comm[1..-1]
	when 'RSET';	comm_rset comm[1..-1]
	when 'TOP';	comm_top comm[1..-1]
	when 'UIDL';	comm_uidl comm[1..-1]
	when 'QUIT';	comm_quit comm[1..-1]
	else
	  err 'invalid command'
	end
      end
    end
    exit
  end

  def err(arg=nil)
    @sock.write(if arg then "-ERR #{arg}\r\n" else "-ERR\r\n" end)
  end

  def ok(arg=nil)
    @sock.write(if arg then "+OK #{arg}\r\n" else "+OK\r\n" end)
  end

  def comm_auth_quit(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    ok 'server signing off' rescue true
    exit
  end

  def comm_user(arg)
    if @user then
      err 'invalid command'
      return
    end
    if arg.size != 1 then
      err 'too few/many arguments'
      return
    end
    ok 'password requred'
    @user = arg[0]
  end

  def comm_pass(arg)
    if not @user then
      err 'invalid command'
      return
    end
    if arg.size != 1 then
      err 'too few/many arguments'
      return
    end
    if auth(@user, arg[0]) then
      to_transaction
      msgs, size = stat
      ok "#{@user} has #{msgs} messages (#{size} octets)"
    else
      sleep 5
      err 'authentication failed'
      exit
    end
  end

  def comm_apop(arg)
    if @user then
      err 'invalid command'
      return
    end
    if arg.size != 2 then
      err 'too few/many arguments'
      return
    end
    if apop_auth(arg[0], arg[1]) then
      @user = arg[0]
      to_transaction
      msgs, size = stat
      ok "#{@user} has #{msgs} messages (#{size} octets)"
    else
      sleep 5
      err 'authentication failed'
      exit
    end
  end  

  def to_transaction()
    reset_msgno
    if not lock then
      err "cannot lock for #{@user}"
      exit
    end
    at_exit do
      unlock()
      write_log
    end
    after_auth_hook(@sock, auth, @mailbox) if defined? after_auth_hook
    @status = :TRANSACTION
    @start_time = Time::now
  end

  def write_log()
    if defined? LogFile and LogFile then
      File::open(LogFile, 'a') do |f|
	f.flock(File::LOCK_EX)
	f.seek(IO::SEEK_END, 0)
	f.puts sock_to_addr(@sock) + ' ' +
	  @start_time.strftime('%Y/%m/%d %H:%M:%S') + ' ' +
	  Time::now.strftime('%Y/%m/%d %H:%M:%S') + ' ' +
	  @user
      end
    end
  end

  def sock_to_addr(s)
    s.getpeername[4,4].split('').collect{|i| i[0].to_s}.join('.')
  end

  def comm_stat(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    n, m = stat
    ok "#{n} #{m}"
  end

  def comm_list(arg)
    if arg.size == 0 then
      n, m = stat
      ok "#{n} messages (#{m} octets)"
      @sock.sync = false
      list_all.each do |n, m|
	@sock.write "#{n} #{m}\r\n"
      end
      @sock.sync = true
      @sock.write ".\r\n"
    elsif arg.size == 1 then
      n, m = list(arg[0].to_i)
      if n then
	ok "#{n} #{m}"
      else
	err 'no such message'
      end
    else
      err 'too many arguments'
    end
  end

  def comm_retr(arg)
    if arg.size != 1 then
      err 'too few/many arguments'
      return
    end
    msg = retr(arg[0].to_i)
    if not msg then
      err 'no such message'
      return
    end
    ok "#{msg.size} octets"
    @sock.sync = false
    msg.each do |line|
      if line[0] == ?. then line[0,0] = '.' end
      @sock.write line
    end
    if msg[-2..-1] != "\r\n"
      @sock.write "\r\n"
    end
    @sock.sync = true
    @sock.write ".\r\n"
  end

  def comm_dele(arg)
    if arg.size != 1 then
      err 'too few/many arguments'
      return
    end
    if dele(arg[0].to_i) then
      ok 'message deleted'
    else
      err 'no such message'
    end
  end

  def comm_noop(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    ok
  end

  def comm_rset(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    rset
    ok
  end

  def comm_top(arg)
    if arg.size != 2 then
      err 'too few/many arguments'
      return
    end
    msg = top arg[0].to_i, arg[1].to_i
    if not msg then
      err 'no such message'
      return
    end
    ok
    @sock.sync = false
    msg.each do |line|
      if line[0] == ?. then line[0,0] = '.' end
      @sock.write line
    end
    if msg[-2..-1] != "\r\n"
      @sock.write "\r\n"
    end
    @sock.sync = true
    @sock.write ".\r\n"
  end

  def comm_uidl(arg)
    if arg.size == 0 then
      ok
      @sock.sync = false
      uidl_all.each do |m, id|
	@sock.write "#{m} #{id}\r\n"
      end
      @sock.sync = true
      @sock.write ".\r\n"
    elsif arg.size == 1 then
      m, id = uidl(arg[0].to_i)
      if m then
	ok "#{m} #{id}"
      else
	err 'no such message'
      end
    else
      err 'too many arguments'
    end
  end

  def comm_quit(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    commit
    ok 'server signing off' rescue true
    exit
  end

end

TPOPS::new

