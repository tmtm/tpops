#!/usr/local/bin/ruby
# $Id: tpops,v 1.23 2002/04/21 05:03:58 tommy Exp $

require 'socket'

$LOAD_PATH.unshift File::dirname($0)

load 'tpops.conf'

Port = 110 unless defined? Port
Hostname = `uname -n`.chomp unless defined? Hostname
ConnectionKeepTime = 60*60 unless defined? ConnectionKeepTime
CommandTimeout = 5*60 unless defined? CommandTimeout
MaildirCRLF = false unless defined? MaildirCRLF
WithInetd = true unless defined? WithInetd
LogFile = nil unless defined? LogFile
ErrorFile = '/var/log/tpops.err' unless defined? ErrorFile

AuthType = 'Passwd' unless defined? AuthType
require 'tpops_auth-'+AuthType.downcase

MailboxType = 'Maildir' unless defined? MailboxType
require 'tpops_mailbox-'+MailboxType.downcase

class TPOPS

  def initialize()
    if WithInetd then
      $stderr = File::open(ErrorFile, 'a')
      connection(Socket::for_fd $stdin.fileno)
    else
      trap "CHLD", nil		# ignore child process's status
      sock = TCPServer::new(Port)
      loop do
	conn = sock.accept
	fork do
	  sock.close
	  connection(conn)
	end
	conn.close
      end
    end
  end

  def connection(sock)
    @sock = sock
    @status = :AUTHORIZATION
    @user = nil
    @apopkey = Auth::apop? ? "<#{$$}.#{Time::now.to_i}@#{Hostname}>" : ''

    Thread::new do sleep ConnectionKeepTime; exit end

    @sock.write "+OK TPOPS ready. #{@apopkey}\r\n"
    loop do
      timeout_thr = Thread::new do sleep CommandTimeout; exit end
      r = @sock.gets
      timeout_thr.kill
      if not r then break end
      r = r.chomp.sub(/\r$/, '')
      comm = r.split
      if comm.size == 0 then next end
      case @status
      when :AUTHORIZATION
	case comm[0].upcase
	when 'QUIT';	comm_auth_quit comm[1..-1]
	when 'USER';	comm_user comm[1..-1]
	when 'PASS';	comm_pass r.split(' ', 2)[1,1]
	when 'APOP';	comm_apop comm[1..-1]
	else
	  err 'invalid command'
	end
      when :TRANSACTION
	case comm[0].upcase
	when 'STAT';	comm_stat comm[1..-1]
	when 'LIST';	comm_list comm[1..-1]
	when 'RETR';	comm_retr comm[1..-1]
	when 'DELE';	comm_dele comm[1..-1]
	when 'NOOP';	comm_noop comm[1..-1]
	when 'RSET';	comm_rset comm[1..-1]
	when 'TOP';	comm_top comm[1..-1]
	when 'UIDL';	comm_uidl comm[1..-1]
	when 'QUIT';	comm_quit comm[1..-1]
	else
	  err 'invalid command'
	end
      end
    end
    exit
  end

  def err(arg=nil)
    @sock.write(if arg then "-ERR #{arg}\r\n" else "-ERR\r\n" end)
  end

  def ok(arg=nil)
    @sock.write(if arg then "+OK #{arg}\r\n" else "+OK\r\n" end)
  end

  def comm_auth_quit(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    ok 'server signing off' rescue true
    exit
  end

  def comm_user(arg)
    if @user then
      err 'invalid command'
      return
    end
    if arg.size != 1 then
      err 'too few/many arguments'
      return
    end
    ok 'password required'
    @user = arg[0]
  end

  def comm_pass(arg)
    if not @user then
      err 'invalid command'
      return
    end
    if arg.size != 1 then
      err 'too few/many arguments'
      return
    end

    auth = Auth::new @user, arg[0]
    if auth.authorized? then
      to_transaction auth
      msgs, size = @mailbox.stat
      ok "#{@user} has #{msgs} messages (#{size} octets)"
    else
      sleep 5
      err 'authentication failed'
      exit
    end
  end

  def comm_apop(arg)
    unless Auth::apop? then
      err 'APOP not supported'
      return
    end
    if @user then
      err 'invalid command'
      return
    end
    if arg.size != 2 then
      err 'too few/many arguments'
      return
    end
    auth = Auth::new arg[0], arg[1], @apopkey
    if auth.authorized? then
      @user = arg[0]
      to_transaction auth
      msgs, size = @mailbox.stat
      ok "#{@user} has #{msgs} messages (#{size} octets)"
    else
      sleep 5
      err 'authentication failed'
      exit
    end
  end  

  def to_transaction(auth)
    if not auth.lock then
      err "cannot lock for #{@user}"
      exit
    end
    at_exit do
      auth.unlock()
      write_log
    end
    @mailbox = Mailbox::new auth.uid, auth.maildir
    after_auth_hook(@sock, auth, @mailbox) if defined? after_auth_hook
    @status = :TRANSACTION
    @start_time = Time::now
  end

  def write_log()
    if LogFile then
      File::open(LogFile, 'a') do |f|
	f.syswrite sock_to_addr(@sock) + ' ' +
	  @start_time.strftime('%Y/%m/%d %H:%M:%S') + ' ' +
	  Time::now.strftime('%Y/%m/%d %H:%M:%S') + ' ' +
	  @user + "\n"
      end
    end
  end

  def sock_to_addr(s)
    s.getpeername[4,4].split('').collect{|i| i[0].to_s}.join('.')
  end

  def comm_stat(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    n, m = @mailbox.stat
    ok "#{n} #{m}"
  end

  def comm_list(arg)
    if arg.size == 0 then
      n, m = @mailbox.stat
      ok "#{n} messages (#{m} octets)"
      @sock.sync = false
      @mailbox.list_all.each do |n, m|
	@sock.write "#{n} #{m}\r\n"
      end
      @sock.sync = true
      @sock.write ".\r\n"
    elsif arg.size == 1 then
      n, m = @mailbox.list(arg[0].to_i)
      if n then
	ok "#{n} #{m}"
      else
	err 'no such message'
      end
    else
      err 'too many arguments'
    end
  end

  def comm_retr(arg)
    if arg.size != 1 then
      err 'too few/many arguments'
      return
    end
    m, size = @mailbox.list(arg[0].to_i)
    if not m then
      err 'no such message'
      return
    end
    ok "#{size} octets"
    @sock.sync = false
    @mailbox.retr(arg[0].to_i) do |line|
      if line[0] == ?. then line[0,0] = '.' end
      @sock.write line
    end
    @sock.sync = true
    @sock.write ".\r\n"
  end

  def comm_dele(arg)
    if arg.size != 1 then
      err 'too few/many arguments'
      return
    end
    if @mailbox.dele(arg[0].to_i) then
      ok 'message deleted'
    else
      err 'no such message'
    end
  end

  def comm_noop(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    ok
  end

  def comm_rset(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    @mailbox.rset
    ok
  end

  def comm_top(arg)
    if arg.size != 2 then
      err 'too few/many arguments'
      return
    end
    if not @mailbox.list(arg[0].to_i) then
      err 'no such message'
      return
    end
    ok
    @sock.sync = false
    @mailbox.top(arg[0].to_i, arg[1].to_i) do |line|
      if line[0] == ?. then line[0,0] = '.' end
      @sock.write line
    end
    @sock.sync = true
    @sock.write ".\r\n"
  end

  def comm_uidl(arg)
    if arg.size == 0 then
      ok
      @sock.sync = false
      @mailbox.uidl_all.each do |m, id|
	@sock.write "#{m} #{id}\r\n"
      end
      @sock.sync = true
      @sock.write ".\r\n"
    elsif arg.size == 1 then
      m, id = @mailbox.uidl(arg[0].to_i)
      if m then
	ok "#{m} #{id}"
      else
	err 'no such message'
      end
    else
      err 'too many arguments'
    end
  end

  def comm_quit(arg)
    if arg.size != 0 then
      err 'too many arguments'
      return
    end
    @mailbox.commit
    ok 'server signing off' rescue true
    exit
  end

end

TPOPS::new

